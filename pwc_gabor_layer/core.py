# AUTOGENERATED! DO NOT EDIT! File to edit: 00_core.ipynb (unless otherwise specified).

__all__ = ['GaborLayer']

# Cell
import functools
import math
import tensorflow as tf
import tensorflow_datasets as tfds
from datetime import datetime
from tensorflow.python.ops import nn_ops
from tensorflow import keras
from fastcore.nb_imports import *
from fastcore.test import *
from fastcore.foundation import *

# Cell
class GaborLayer(keras.layers.Layer):
    def __init__(self, filters, kernel_size, orientations, learn_orientations=False,
                 use_bias=True, activation='relu', strides=(1, 1), padding='SAME', use_alphas=True, **kwargs):
        super().__init__(**kwargs)
        self.filters = filters
        self.kernel_size = kernel_size
        self.orientations = orientations
        self.learn_orientations = learn_orientations
        self.use_bias = use_bias
        self.strides = strides
        # can use strings as activation functions
        self.activation = keras.activations.get(activation)
        self.padding = padding
        self.rank = 2
        self.pi = tf.constant(math.pi, dtype=tf.float32)
        self.use_alphas = use_alphas

# Cell
@patch
def create_xy_grid(self:GaborLayer):
    xmin, xmax = -1.0, 1.0
    ymin, ymax = -1.0, 1.0
    x_space = tf.linspace(xmin, xmax, self.kernel_size[0])
    y_space = tf.linspace(ymin, ymax, self.kernel_size[1])
    x, y = tf.meshgrid(y_space, x_space)

    return x, y

# Cell
@patch
def build(self:GaborLayer, batch_input_shape):
        self.input_channels = batch_input_shape[-1]

        self.gammas = self.add_weight(name='gammas', shape=[self.filters, 1, 1, 1, 1],
                                            initializer='random_normal', trainable=True)
        self.psis = self.add_weight(name='psis', shape=[self.filters, 1, 1, 1, 1],
                                   initializer='random_normal', trainable=True)
        self.sigmas = self.add_weight(name='sigmas', shape=[self.filters, 1, 1, 1, 1],
                                   initializer='random_normal', trainable=True)
        self.lambdas = self.add_weight(name='lambdas', shape=[self.filters, 1, 1, 1, 1],
                                   initializer='random_normal', trainable=True)

        if self.use_alphas:
            self.alphas = self.add_weight(name='alphas', shape=[self.filters * self.orientations, 1, 1, 1],
                                   initializer='random_normal', trainable=True)

        if self.use_bias:
            self.bias = self.add_weight(name='bias', shape=[self.filters * self.orientations],
                                         initializer='zeros')

        thetas = (tf.range(0, self.orientations, dtype=tf.float32) * 2 * self.pi) / self.orientations
        thetas = tf.reshape(thetas, (self.orientations, 1 ,1, 1))
        self.thetas = tf.Variable(thetas, name='thetas', trainable=self.learn_orientations)

        x, y = self.create_xy_grid()

        x = x[None, :, :, None]
        y = y[None, :, :, None]

        x = tf.repeat(x, repeats=self.input_channels, axis=-1)
        y = tf.repeat(y, repeats=self.input_channels, axis=-1)

        sines = tf.sin(self.thetas)
        cosines = tf.cos(self.thetas)

        self.sines = sines
        self.cosines = cosines
        xprime = x * cosines - y * sines
        yprime = x * sines + y * cosines

        xprime = xprime[None, :, :]
        yprime = yprime[None, :, :]


        self.x = tf.Variable(xprime, name='x', trainable=False)
        self.y = tf.Variable(yprime, name='y', trainable=False)

        self.kernel = self.create_kernel()

        self._convolution_op = functools.partial(nn_ops.convolution_v2, strides=self.strides,
                                                padding=self.padding,
                                                name="Gabor_Convolution")

        super(GaborLayer, self).build(batch_input_shape)

# Cell
@patch
def create_kernel(self:GaborLayer):
    ori_y_term = self.gammas ** 2 * self.y ** 2
    exponent_ori = (self.x ** 2 + ori_y_term) * self.sigmas ** 2
    gaussian_term_ori = tf.exp(-exponent_ori)
    cosine_term = tf.cos(self.x * self.lambdas + self.psis)
    ori_gb = gaussian_term_ori * cosine_term
    self.ori_gb = ori_gb
    ori_gb = tf.reshape(ori_gb,
                        (self.filters * self.orientations,
                         *self.kernel_size, self.input_channels))

    if self.use_alphas:
        ori_gb = self.alphas * ori_gb

    return ori_gb

# Cell
@patch
def call(self:GaborLayer, X):
    bs, h, w, inp_channels = X.shape

    kernel = tf.transpose(self.kernel, [1, 2, 3, 0])

    X = self._convolution_op(X, kernel)

    if self.use_bias:
        X = tf.nn.bias_add(X, self.bias)

    X = self.activation(X)
    return X
